"""
Middleware de logging avanc√© pour FastAPI
Trace toutes les requ√™tes HTTP avec contexte complet et mesure de performance

Principes:
- Observabilit√© totale: Chaque requ√™te est trac√©e
- Correlation IDs: Permet de suivre une requ√™te √† travers tous les logs
- Performance monitoring: Mesure automatique des temps de r√©ponse
- Security audit: Log des √©v√©nements de s√©curit√©
- Error tracking: Capture d√©taill√©e des erreurs
"""
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.requests import Request
from starlette.responses import Response
from starlette.types import ASGIApp
from uuid import uuid4
from datetime import datetime
import time
import structlog
from typing import Callable, Optional
import json

from app.core.logging.enhanced_logging import request_id_var, user_id_var

logger = structlog.get_logger(__name__)


class EnhancedLoggingMiddleware(BaseHTTPMiddleware):
    """
    Middleware de logging enrichi pour tracer toutes les requ√™tes
    
    Fonctionnalit√©s:
    - G√©n√©ration automatique de correlation ID (request_id)
    - Logging d√©but/fin de requ√™te avec dur√©e
    - Extraction automatique de l'user_id depuis le token JWT
    - Logging des headers pertinents
    - Mesure de performance avec alertes sur requ√™tes lentes
    - Gestion des erreurs avec contexte complet
    """
    
    def __init__(
        self,
        app: ASGIApp,
        slow_request_threshold: float = 1.0,
        log_request_body: bool = False,
        log_response_body: bool = False,
        excluded_paths: Optional[list] = None
    ):
        """
        Initialiser le middleware
        
        Args:
            app: Application ASGI
            slow_request_threshold: Seuil (secondes) pour consid√©rer une requ√™te comme lente
            log_request_body: Logger le corps des requ√™tes (attention: donn√©es sensibles)
            log_response_body: Logger le corps des r√©ponses (attention: taille)
            excluded_paths: Chemins √† exclure du logging (ex: /health, /metrics)
        """
        super().__init__(app)
        self.slow_request_threshold = slow_request_threshold
        self.log_request_body = log_request_body
        self.log_response_body = log_response_body
        self.excluded_paths = excluded_paths or [
            "/health",
            "/metrics",
            "/docs",
            "/redoc",
            "/openapi.json"
        ]
    
    async def dispatch(
        self, 
        request: Request, 
        call_next: Callable
    ) -> Response:
        """
        Traiter la requ√™te avec logging complet
        
        Args:
            request: Requ√™te HTTP
            call_next: Fonction pour appeler le handler suivant
            
        Returns:
            Response HTTP
        """
        # V√©rifier si le chemin est exclu
        if any(request.url.path.startswith(path) for path in self.excluded_paths):
            return await call_next(request)
        
        # G√©n√©rer un ID unique pour la requ√™te
        request_id = str(uuid4())
        request_id_var.set(request_id)
        
        # Extraire l'user_id depuis le token JWT si pr√©sent
        user_id = self._extract_user_id_from_request(request)
        if user_id:
            user_id_var.set(user_id)
        
        # Pr√©parer les informations de base de la requ√™te
        request_info = {
            "request_id": request_id,
            "method": request.method,
            "path": request.url.path,
            "query_params": dict(request.query_params) if request.query_params else {},
            "client_ip": self._get_client_ip(request),
            "user_agent": request.headers.get("user-agent"),
            "user_id": user_id,
            "timestamp": datetime.utcnow().isoformat()
        }
        
        # Logger le d√©but de la requ√™te
        logger.info(
            f"üåê ‚û°Ô∏è  {request.method} {request.url.path}",
            **request_info,
            event_type="request_started"
        )
        
        # Logger le body si activ√© (attention aux donn√©es sensibles)
        if self.log_request_body and request.method in ["POST", "PUT", "PATCH"]:
            try:
                body = await self._get_request_body(request)
                if body:
                    logger.debug(
                        "Request body",
                        request_id=request_id,
                        body=body[:500]  # Limiter √† 500 caract√®res
                    )
            except Exception as e:
                logger.warning(
                    "Failed to read request body",
                    request_id=request_id,
                    error=str(e)
                )
        
        # Mesurer le temps de traitement
        start_time = time.time()
        status_code = 500  # Par d√©faut en cas d'erreur
        error_occurred = None
        
        try:
            # Traiter la requ√™te
            response = await call_next(request)
            status_code = response.status_code
            
        except Exception as e:
            error_occurred = e
            status_code = 500
            
            # Logger l'erreur avec contexte complet
            logger.error(
                f"‚ùå Erreur non captur√©e dans {request.method} {request.url.path}",
                request_id=request_id,
                method=request.method,
                path=request.url.path,
                error_type=type(e).__name__,
                error_message=str(e),
                user_id=user_id,
                exc_info=True,
                event_type="request_error"
            )
            
            # Re-lever l'erreur pour qu'elle soit g√©r√©e par FastAPI
            raise
            
        finally:
            # Calculer la dur√©e
            duration = time.time() - start_time
            
            # Pr√©parer les informations de r√©ponse
            response_info = {
                "request_id": request_id,
                "method": request.method,
                "path": request.url.path,
                "status_code": status_code,
                "duration_seconds": round(duration, 3),
                "duration_ms": round(duration * 1000, 2),
                "user_id": user_id,
                "event_type": "request_completed"
            }
            
            # D√©terminer le niveau de log selon le statut et la dur√©e
            log_level = self._determine_log_level(status_code, duration)
            emoji = self._get_status_emoji(status_code)
            
            # Logger la fin de la requ√™te
            log_message = f"{emoji} {request.method} {request.url.path} [{status_code}] - {duration*1000:.2f}ms"
            
            getattr(logger, log_level)(
                log_message,
                **response_info
            )
            
            # Alerte sp√©cifique pour requ√™tes lentes
            if duration > self.slow_request_threshold:
                logger.warning(
                    f"‚ö†Ô∏è  SLOW REQUEST: {request.method} {request.url.path}",
                    request_id=request_id,
                    duration_seconds=round(duration, 3),
                    threshold_seconds=self.slow_request_threshold,
                    exceeded_by_seconds=round(duration - self.slow_request_threshold, 3),
                    event_type="slow_request"
                )
            
            # Logger les √©v√©nements de s√©curit√©
            self._log_security_events(request, status_code, user_id or "anonymous", request_id)
        
        return response
    
    def _extract_user_id_from_request(self, request: Request) -> Optional[str]:
        """
        Extraire l'user_id depuis le token JWT
        
        Args:
            request: Requ√™te HTTP
            
        Returns:
            User ID ou None
        """
        try:
            # Chercher dans les headers Authorization
            auth_header = request.headers.get("authorization", "")
            if auth_header.startswith("Bearer "):
                token = auth_header.split(" ")[1]
                
                # D√©coder le token (sans v√©rifier la signature pour le logging)
                import jwt
                try:
                    payload = jwt.decode(token, options={"verify_signature": False})
                    return payload.get("sub") or payload.get("user_id")
                except Exception:
                    pass
        except Exception:
            pass
        
        return None
    
    def _get_client_ip(self, request: Request) -> str:
        """
        Obtenir l'adresse IP du client (g√©rer les proxies)
        
        Args:
            request: Requ√™te HTTP
            
        Returns:
            Adresse IP
        """
        # V√©rifier les headers de proxy
        forwarded = request.headers.get("x-forwarded-for")
        if forwarded:
            return forwarded.split(",")[0].strip()
        
        real_ip = request.headers.get("x-real-ip")
        if real_ip:
            return real_ip
        
        # Fallback sur l'IP directe
        if request.client:
            return request.client.host
        
        return "unknown"
    
    async def _get_request_body(self, request: Request) -> Optional[dict]:
        """
        Lire le body de la requ√™te
        
        Args:
            request: Requ√™te HTTP
            
        Returns:
            Body pars√© ou None
        """
        try:
            body_bytes = await request.body()
            if body_bytes:
                body_str = body_bytes.decode('utf-8')
                return json.loads(body_str)
        except Exception:
            pass
        
        return None
    
    def _determine_log_level(self, status_code: int, duration: float) -> str:
        """
        D√©terminer le niveau de log selon le statut et la dur√©e
        
        Args:
            status_code: Code de statut HTTP
            duration: Dur√©e de traitement
            
        Returns:
            Niveau de log (debug, info, warning, error)
        """
        # Erreurs serveur -> error
        if status_code >= 500:
            return "error"
        
        # Erreurs client -> warning
        if status_code >= 400:
            return "warning"
        
        # Requ√™tes lentes -> warning
        if duration > self.slow_request_threshold:
            return "warning"
        
        # Sinon -> info
        return "info"
    
    def _get_status_emoji(self, status_code: int) -> str:
        """
        Obtenir un emoji selon le statut HTTP
        
        Args:
            status_code: Code de statut HTTP
            
        Returns:
            Emoji
        """
        if status_code < 300:
            return "‚úÖ"
        elif status_code < 400:
            return "‚Ü™Ô∏è "
        elif status_code < 500:
            return "‚ö†Ô∏è "
        else:
            return "‚ùå"
    
    def _log_security_events(
        self,
        request: Request,
        status_code: int,
        user_id: str,
        request_id: str
    ):
        """
        Logger les √©v√©nements de s√©curit√© importants
        
        Args:
            request: Requ√™te HTTP
            status_code: Code de statut
            user_id: ID utilisateur
            request_id: ID de la requ√™te
        """
        # √âchecs d'authentification
        if status_code == 401:
            logger.warning(
                f"üîê Tentative d'acc√®s non authentifi√©e: {request.method} {request.url.path}",
                request_id=request_id,
                path=request.url.path,
                client_ip=self._get_client_ip(request),
                event_type="authentication_failed"
            )
        
        # √âchecs d'autorisation
        elif status_code == 403:
            logger.warning(
                f"üö´ Acc√®s refus√©: {request.method} {request.url.path}",
                request_id=request_id,
                path=request.url.path,
                user_id=user_id,
                client_ip=self._get_client_ip(request),
                event_type="authorization_failed"
            )
        
        # Trop de requ√™tes (rate limit)
        elif status_code == 429:
            logger.warning(
                f"üö¶ Rate limit d√©pass√©: {request.method} {request.url.path}",
                request_id=request_id,
                path=request.url.path,
                user_id=user_id,
                client_ip=self._get_client_ip(request),
                event_type="rate_limit_exceeded"
            )
        
        # Connexion r√©ussie
        elif request.url.path in ["/api/v1/auth/login", "/api/v1/auth/token"] and status_code == 200:
            logger.info(
                f"üîê Connexion r√©ussie",
                request_id=request_id,
                user_id=user_id,
                client_ip=self._get_client_ip(request),
                event_type="login_success"
            )
        
        # D√©connexion
        elif request.url.path == "/api/v1/auth/logout" and status_code == 200:
            logger.info(
                f"üëã D√©connexion",
                request_id=request_id,
                user_id=user_id,
                client_ip=self._get_client_ip(request),
                event_type="logout"
            )

